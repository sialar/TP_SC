verbosity=0;

int n = 20;

border ePCB(t=0, 1.0){x=t; y=0; label=1 ;} ;
border ea(t=1.0, 3.0){x=t; y=0; label=2 ;} ;
border lPCB(t=0, 5.0){x=3.0; y=t; label=3;} ;
border ga(t=3.0, 1.0){x=t; y=5.0; label=4;} ;
border gPCB(t=1.0, 0){x=t; y=5.0; label=5;} ;
border hPCB(t=5.0, 0){x=0; y=t; label=6 ;} ;



border lIC1(t=2.2, 1.0){x=1.0; y=t; label=7;} ;
border gIC1(t=1.0, 2.0){x=t; y= 1.0; label=8;} ;
border hIC1(t=1.0, 2.2){x=2.0; y=t; label=9;} ;
border eIC1(t=2.0, 1.0){x=t; y= 2.2; label=10;} ;

border lIC2(t=4.2, 3.0){x=1.0; y=t; label=11;} ;
border gIC2(t=1.0, 2.0){x=t; y= 3.0; label=12;} ;
border hIC2(t=3.0, 4.2){x=2.0; y=t; label=13;} ;
border eIC2(t=2.0, 1.0){x=t; y= 4.2; label=14;} ;

border b1(t=0.0, 1.0){x=1.0; y=t; label=15;} ;
border b2(t=2.2, 3.0){x=1.0; y=t; label=16;} ;
border b3(t=4.2, 5.0){x=1.0; y=t; label=17;} ;


//mesh Th = buildmesh(ePCB(n) + b1(n) + lIC1(-n) + b2(n) + lIC2(-n) + b3(n) + gPCB(n) + hPCB(n));

mesh Th = buildmesh(ePCB(n) + ea(n) + hPCB(n) + gPCB(n) + ga(n) + lPCB(n)
+ lIC1(n) + hIC1(n) + eIC1(n) + gIC1(n)
+ lIC2(n) + hIC2(n) + eIC2(n) + gIC2(n)
+ b1(n) + b2(n) + b3(n));


mesh Th2 = buildmesh(ea(n) + lPCB(n) + ga(n) + b3(-n) + eIC2(-n) + hIC2(-n) + gIC2(-n) + b2(-n) + eIC1(-n) + hIC1(-n) + gIC1(-n) + b1(-n));

mesh Th3 = buildmesh(ePCB(n) + b1(n) + lIC1(-n) + b2(n) + lIC2(-n) + b3(n) + gPCB(n) + hPCB(n));

mesh Th4 = buildmesh(lIC1(n) + gIC1(n) + hIC1(n) + eIC1(n));

mesh Th5 = buildmesh(lIC2(n) + gIC2(n) + hIC2(n) + eIC2(n));


plot(Th);

fespace Vh(Th2,P1);

real nu = 0.0025, dt = 0.2;								//Reynolds=200
Vh w,u = 0, v =0, p = 0, q=0;
real epsv = 1e-6, epsu = 1e-6, epsp = 1e-6;						// Eps CG ..


// def of Matrix dtMx and dtMy√®
matrix dtM1x,dtM1y;
macro BuildMat()
	{ /*for memory managenemt*/

	varf vM(unused,v) = int2d(Th2)(v) ;
	varf vdx(u,v) = int2d(Th2)(v*dx(u)*dt) ;
	varf vdy(u,v) = int2d(Th2)(v*dy(u)*dt) ;
	real[int] Mlump = vM(0,Vh);
	real[int] one(Vh.ndof); one = 1;
	real[int] M1 =  one ./ Mlump;
	matrix dM1 = M1;
	matrix Mdx = vdx(Vh,Vh);
	matrix Mdy = vdy(Vh,Vh);
	dtM1x = dM1*Mdx;
	dtM1y = dM1*Mdy;
} //    EOF

BuildMat real err=1, outflux=1;
for(int n=0;n<300;n++){
	Vh uold = u,  vold = v, pold=p;
	solve pb4u(u,w,init=n,solver=CG,eps=epsu) = int2d(Th2)(u*w/dt +nu*(dx(u)*dx(w)+dy(u)*dy(w))) - int2d(Th2)((convect([uold,vold],-dt,uold)/dt-dx(p))*w)
						   + on(2,u = 50/*4*y*(5-y)+3*/)  		  //entree du courant
						   + on(3,17,14,13,12,16,10,9,8,15,u = 0) ;	  // condition dirichlet sur les bords

	//    Neuman on Gamma3
	//plot(u);
	Vh modU = sqrt((u*u) + (v*v));
        plot(modU,value=true,fill = 1);

	solve pb4v(v,w,init=n,solver=CG,eps=epsv) = int2d(Th2)(v*w/dt +nu*(dx(v)*dx(w)+dy(v)*dy(w))) - int2d(Th2)((convect([uold,vold],-dt,vold)/dt-dy(p))*w)
						    + on(2,3,4,17,14,13,12,16,10,9,8,15,v = 0);


	solve pb4p(q,w,solver=CG,init=n,eps=epsp) =int2d(Th2)(dx(q)*dx(w)+dy(q)*dy(w)) - int2d(Th2)((dx(u)+ dy(v))*w/dt)
						   + on(4,q=0);					// to have absolute epsilon in CG algorithm.


/*
	problem Stokes([u1,u2,p],[v1,v2,q]) = int2d(Th2)(dt*dx(u1)*dx(v1) + dt*dx(u2)*dx(v2) + dt*dy(u1)*dy(v1) + dt*dy(u2)*dy(v2))
					+ int2d(Th2)(dx(p)*v1 + dy(p)*v2) + int2d(Th2)((dx(u1) + dy(u2))*q)
					+ on(b3,eIC2,hIC2,gIC2,b2,eIC1,hIC1,gIC1,b1, u1=0, u2=0) + on(lPCB,u1=0, u2=0) + on(ea,u1=50, u2=50);

*/
	epsv = -abs(epsv);
	epsu = -abs(epsu);
	epsp = -abs(epsp);


	p = pold-q;
	u[] += dtM1x*q[];
	v[] += dtM1y*q[];
/*
	if(n%50==49){
		Th2 =adaptmesh(Th2,[u,v],q,err=0.04,nbvx=100000);
		//plot(Th, wait=true);
		BuildMat									//    rebuild mat.
	}

*/


	err = sqrt(int2d(Th)(square(u-uold)+square(v-vold))/Th.area) ;
	outflux = int1d(Th)( [u,v]'*[N.x,N.y]) ;
	cout << " iter " << n << " Err L2 = " << err<<  " flux sortant = "<< outflux << endl;
	if(err < 1e-3) break;
}


assert(abs(outflux)< 2e-3);			//    verifaction ...
plot(p,wait=1,ps="NSprojP.eps");
plot(u,wait=1,ps="NSprojU.eps");








